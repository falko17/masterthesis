\documentclass[../thesis]{subfiles}
\graphicspath{{\subfix{../figures/}}}

\begin{document}
\chapter{Conclusion}\label{ch:conclusion}

\lettrine[lines=3]{\textcolor{Maroon}{U}}{ltimately}, having now successfully completed both the implementation and the user study, we are ready to conclude this thesis.
In this final chapter, we do so by first pointing out some limitations of the work presented here, mentioning some possibilities of future expansions, and finally, by offering some closing remarks.

\section{Limitations}
We will first go over a few ways in which the implementation and user study are limited.

\subsection{Implementation}
\paragraph{Possible Bugs}
For some \gls{ls}, there sometimes seem to be slight inconsistencies between the generated \glspl{city} and the actual projects.
For example, I noticed that the generated city in \cref{fig:aaocity} contains some empty modules, even though the module's contents themselves exist and are grouped together, which seems to be a quirk of the Rust Analyzer.
Similarly, while preparing \SEE{} for the evaluation, I noticed that Java package hierarchies were not collected properly by the \gls{ls}, so I had to add some workaround code that infers the structure from the file paths.
To make the \gls{lsp} import reliable and production-ready, it would be a good idea to do detailed tests for each \gls{ls} and add more special-purpose fixes, if necessary.

\paragraph{Performance}
As we have seen in \cref{sec:techeval}, generation times get less bearable as we increase the number of edges.
The generation time for SpotBugs, under realistic settings (only reference edges and node types for classes and bigger components enabled), was on average at about nine minutes.
This is not ideal, and generation is currently infeasible for projects on the order of a million \gls{loc}.
To make this truly usable for very large projects---which is where \glspl{city} also have arguably the biggest use---more investigation into how to increase performance further might be necessary.

\paragraph{City Editor}
So far, \gls{lsp} \glspl{city} cannot be created within actual builds of \SEE{}, because the editor \gls{ui} for the \gls{provider} is only available within the \gls{editor}.
\SEE{} does have an in-game \gls{city} creation menu which uses the editor \gls{ui} as a base, but the \gls{lsp} import menu would still need to be configured to work with it correctly.
Additionally, the implementation for this thesis added a progress bar to the \gls{provider} \gls{ui} that should also be incorporated into the in-game dialog.

\paragraph{\Gls{ls} Differences}
There are still a few suboptimal aspects for the \gls{city} generation that are due to differences between the various \glspl{ls}.
For example, not all of them support the hierarchic \texttt{DocumentSymbol} format that we need to actually construct the graph---since this is the modern format, though, \glspl{ls} should over time be updated to output it instead of the outdated \texttt{SymbolInformation}.
Another possible point of concern is that, due to those differences, \glspl{city} generated by different \glspl{ls} are not really comparable to one another.
An example of this is that the Jedi Python \gls{ls} outputs different \glspl{city} than the Pyright \gls{ls}\footnote{
	This may be due to a variety of factors, such as slight differences in the \glspl{range} of the code elements (which causes our matching algorithm to return different nodes for edges), or differences in how a given \gls{ls} maps a node onto the (very TypeScript-oriented) \gls{lsp} symbol types.
}, even though both are written for the same programming language.
Finally, only very few \glspl{ls} support the \emph{pull diagnostics} \gls{capability}.
For all other ones, we need to collect the pushed diagnostics in the background, meaning we could easily miss some if the import algorithm is done before all diagnostics have been pushed.

\subsection{Evaluation}
We already went over some important threats to validity in \cref{sec:threats}.
Apart from those, another major limitation may be that we have not actually evaluated most of the implementation---as explained in \cref{sec:plan}, we basically only evaluated the changes from \cref{sec:generate}, leaving out almost all features implemented in \cref{sec:intocity,sec:intowindow}.
Even under those constraints, what we really evaluated in \cref{ch:evaluation} was \emph{generated} \gls{city} rather than the \emph{generation of the} \gls{city}, although we did at least evaluate the latter in the technical evaluation in \cref{sec:techeval}.
\Cref{sec:intocity,sec:intowindow}, however, remain very under-evaluated---a further user study could make sure that \gls{lsp}-enabled \glspl{city} and \glspl{window} are a usable combination, maybe again by comparing those to \gls{vscode}.

\section{Future Work}
I see many opportunities to build on this thesis and its implementation.
Since there is no real unifying thread here, I will just list these ideas for future work individually:
\begin{itemize}
	\item In this thesis, we constrained ourselves to "read-only" \glspl{capability}.
	      Adding support for editing-related \glspl{capability} can have two different manifestations:
	      \begin{itemize}
		      \item Editable \glspl{window} with the full \gls{lsp} feature set would basically turn them into "proper" \glspl{ide}, and having a full-fledged \gls{ide} within \SEE{} would reduce friction when working with \glspl{city} (as compared to having to switch over to, \eg, \gls{vscode}).
		      \item There are various ways to integrate editing \glspl{capability} into \glspl{city}.
		            As an example, \gls{lsp} offers so-called \emph{Code Actions} (see \cref{subsec:unplanned}), which often provide automatic fixes for \glspl{smell}, so one could extend the erosion features to offer fixing all fixable \glspl{smell}.
		            Another example would be the ability to rename nodes in the \gls{city}, with those renames applied across the actual source code via the \emph{Rename} \gls{capability}.
	      \end{itemize}
	\item Additionally, we excluded two other sets of \glspl{capability}:
	      Ones that are too niche, and ones that are too complex.
	      The former ones may be useful in some contexts, but especially the latter set contains some very handy tools, such as the \emph{Folding Range} \gls{capability}, which allows the user to collapse certain ranges (\eg, every function, allowing them to see all function signatures in collapsed form).
	\item Currently, \glspl{ls} need to be installed manually and must lie in the \texttt{PATH} for \SEE{} to detect them.
	      A possible future addition could be to implement something like \emph{Mason}~\cite{boman2025} that contains a registry of available \glspl{ls} and offers to install\footnote{
		      Where "install" does not have to refer to a system-wide installation, but could just involve placing the binary into a \SEE{}-local folder.
	      } them automatically so that they can subsequently be used in \SEE{}.
	\item While the focus of this thesis was on \SEE{}, \cref{alg:generate,alg:interval} are general enough to port them over to other \gls{city} implementations, or---even better---into a separate tool or library that generates a \gls{gxl} file out of the input project.
	\item Instead of \gls{lsp}, one could utilize \gls{lsif} to construct \glspl{city} fully remotely, that is, without having a local copy of the analyzed project.
	      In the most advanced form, the user would just need to enter, for example, a GitHub link, and then \SEE{} would utilize \gls{lsif} information in combination with GitHub's REST API to construct the city.
	      If the user tries to open a \gls{window}, the corresponding file could be retrieved using the same API, or perhaps using git's \emph{sparse checkout} feature.
\end{itemize}

\section{Closing Remarks}
\fxfatal{}

\chapterendornament{79}{0.2}
